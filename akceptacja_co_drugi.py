def codrugidane(dane1,dane2):
    """
    Inputs:\n
    dane1 - string of 20000 bytes\n
    dane2 - string of 20000 bytes\n
    ------------------\n
    Output:\n
    string of bytes made from dane1 and dane2\n
    """
    ret=''
    dane1=dane1.split('\n')
    dane2=dane2.split('\n')
    k=0
    while len(ret)<=20000:
        ##Pierwszy warunek jest spowodowany wystepujacymi anomaliami z portu szeregowego
        if dane1[k] in ["0","1"] and dane2[k] in ["0","1"]:
            if k%2==0:
                ret+=dane1[k]
            else:
                ret+=dane2[k]
        else:
            print k,dane[k],len(dane),len(ret)
        k+=1
    return ret

def codrugizpliku(input1,input2,output):
    """
    Inputs:\n
    input1 - string, name of the file with generated bytes\n
    input2 - string, name of the file with generated bytes\n
    output - string, name of the final file, after changes from chapter 6.1.1\n
    ------------------
    Output:\n
    None, function saves new string of bytes in output file\n
    """
    plik1=open(input1,'r').read()
    plik2=open(input2,'r').read()
    dane=codrugidane(plik1,plik2)
    plik_o=open(output,'w')
    plik_o.write(dane)
    plik_o.close()
    return "done"

def akceptacja_co_drugi(plik_in,plik_out):
    """
    Inputs:\n
    plik_in - string, name of the file with generated bytes, only the prefix without sumple number\n
    plik_out - string, name of final file for saving new bytes\n
    ------------------\n
    Output:\n
    None, function call codrugizpliku() 10 times\n
    """
    for i in range(1,21,2):
        codrugizpliku(plik_in+str(i)+".txt",plik_in+str(i+1)+".txt",
                 plik_out+str((i+1)/2)+".txt")

if __name__ == '__main__':
    akceptacja_co_drugi("danemic/plik_mic","mic_codrugi/plik_mic_codrugi")
